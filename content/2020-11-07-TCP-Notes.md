Title: TCP - Notes
Date: 2020-11-07
Tags: CS
Status: draft
<a id="org67a75b6"></a>

# TCP or Transmission Control Protocol

The tcp is a protocol that is responsible for making sure that small
packets of data can get to their destinations reliably.  

It has a vat array of features that are designed so that tcp offers
the best throughput and ensures quality of the transmission media,
i.e. TCP will be as fast as possible without abusing the
transmission media/channel.

# Table of Contents

1.  [TCP or Transmission Control Protocol](#org67a75b6)
    1.  [TCP Packet](#orgdffa68d)
    2.  [TCP sockets](#org78db444)
    3.  [The Sequence number](#org9101809)
    4.  [The Acknowledgement Number](#org3bef25f)
    5.  [A complete TCP flow](#orge90475e)
    6.  [Connection Establishment (3-way handshake)](#org07c0504)
    7.  [Connection Tear-down (4-way handshake)](#orgfd0a23a)
    8.  [The tcp state machines](#org61adb36)
    9.  [Tcp RST](#org9331cf6)
    10. [TCP Flow Control (Window Size)](#orgc33e07e)
    11. [TCP Congestion control](#org449f10d)
    12. [TIME<sub>WAIT</sub> Assassinations](#orge80387b)
    13. [Selective Acknowledgements (sack)](#org23b85fd)




<a id="orgdffa68d"></a>

## TCP Packet

Each layer works with a certain *unit* of data. This unit is called
the <span class="underline">Protocol Data Unit</span>.

In TCP the PDU is a *segment*. TCP takes the data from upper layers and
divides it into small chunks; then it adds TCP segment information on
these chunks and creates the TCP segments. Then IP information is
added onto these segments to create IP datagrams. These are the PDUs
handled by the lower layer (Network). IP datagrams are called *packets*.


<a id="org78db444"></a>

## TCP sockets

Sockets act like an interface through which you can send data to
and receive data form. It basically is an abstraction layer on top
the low leave networking hardware stuff (the NIC, the ring buffer, the
OS etc)

To establish a connection you ask your OS to establish a connection to
another computer (ip:port) and once that is done, you (your
application) will have a socket. At the simplest level the socket can
be very simple, you can just *send* and *receive* from the socket.


<a id="org9101809"></a>

## The Sequence number

This is a number that is used to track the total amount of data sent
in that session. This has a special function during connection
setup. Apart from that, this value is also used for correct ordering
of packets and to detect packet loss and re-transmission. 

It is incremented on every byte sent.

If the SYN flag is set, then it means that this is the first segment
of a connection, thus the sequence number is random. However the
resulting ack of this SYN packet is the random seq number + 1.

Note the increase in the ack no even though no data was sent. This is
called the <span class="underline">ghost byte</span> This byte is the reason that the <span class="underline">ack no</span> is
always 1 ahead of the last seq no. It's always the next expected seq
no.


<a id="org3bef25f"></a>

## The Acknowledgement Number

This is the value of the sequence number of the next segment that the
receiver is expecting.

This is used to detect if there is any packet loss, because if the
sender does not a get an ACK within a time-frame, then it will
re-transmit (there are other rules here as well).

Ack is very important in TCP because a lot of functions of TCP
revolves around whether the receiver is getting all the packets
that are being sent. This is what means by a connection oriented
protocol. The sender and the receiver need to be in sync. 

TCP also does rate limiting on the sender's side if it figures out
that the channel is getting congested or the receiver is not able
to handle the load. All of this is enabled through the
acknowledgement number.


<a id="orge90475e"></a>

## A complete TCP flow

A complete TCP flow includes the following parts.

1.  Connection Establishment
2.  Communication
3.  Connection Tear Down

![img](/assets/images/tcp/2020-10-24-13-55-17_tcp_flow.png) 


#### Note ####

Once Connection is set up, both sides can send data, thus it does
not make sense to talk in terms of client-server. Because these
things tend to keep changing (unless it makes sense to use
server-client).

We will talk about *this-side* as the one who is sending the said
packets, and *the other side* as the side who is the intended
recipient.


<a id="org07c0504"></a>

## Connection Establishment (3-way handshake)

As TCP is a connection oriented protocol, both sides need to agree
to a set of rules before any communication can take place. This is
called setting up the <span class="underline">tcp connection</span> or <span class="underline">connection
establishment</span> and is received through a three-way handshake.

The parts involved are here (in-order):

-   SYN
-   SYN-ACK
-   ACK



### SYN

When the *client* wants to establish a new connection with the
*server*, it sends a packet with the **SYN** flag set.

This end is now in **SYN_SENT** state.


### SYN-ACK

When *server* gets a request for a new connection (i.e. gets a
packet with the **SYN** flag set), it sends out a packet with both
the **SYN** and the **ACK** flags set.

This serves dual purpose. It tells the client that the server has
in-fact received the SYN and that the server is also ready to start
receiving traffic. 

This end is now in **SYN_RECEIVED** state.


### ACK

This is used to signal to the server that the client has in-fact received the SYN-ACK.


<a id="orgfd0a23a"></a>

## Connection Tear-down (4-way handshake)

During connection tear-down a 4-way handshake takes place between
the client and the server. This is done to ensure that both the
client and the server have finished sending data. The handshake
enabled either side to acknowledge that the other side wants to
close to close the connection, but at the same time, the other end
needs the data it asked for. 

Imagine a situation where the client is asking for a web-page and
the request is short, so the client sends a *FIN* as soon as the
request payload is sent. This indicates that it does not intend to
send any more data.

Now, the server can keep on sending as much data as it was asked
(while acknowledging that the client is not going to send
anything). Once the server has finished sending data, it can tell
the client that the server is also going to close its side of the
connection.

The 4 steps are :

-   FIN (from Side A; this side is performing the active-close)
-   ACK (from Side B)
-   FIN (from Side B)
-   ACK (from Side A)

(side A & B are arbitrary)


<a id="org04b22f6"></a>

### FIN (from side A)

This flag is sent by whoever wants to close the connection first.
This indicates to the other end that *this side* has finished
sending data.

(This side can still receive data from the other side)


<a id="orgf9c2b55"></a>

### ACK (from side B)

This is sent when one side receives a **FIN**. It indicates that the
other side wishes to terminate the connections. Now it informs the
application using the TCP connection that the other side wishes to
close the connection.


<a id="org20630e0"></a>

### FIN (from side B)

When the application on side B is ready to close the connection,
it does a *close* and then a FIN is sent to side A.

At this point the side which originally asked to close the
connection, has received an ACK from its pair, and has also
received a FIN from that side.

This indicates that both sides have acknowledged that they have
finished sending data and are closing the connections


<a id="org3b5ce3f"></a>

### ACK (from side A)

Now side A has acknowledged that it has received the **FIN** from
the other side.  

This is important in TCP because in the absence of an ACK the
protocols re-transmission mechanisms kick in.


<a id="org61adb36"></a>

## The tcp state machines

   The TCP protocol can be represented as a State Machine, using tcp
*commands* as labels for the transition. The interesting part about
this state machine is that there are two parts of the state machine we
need to keep track of. The client and the server.

This is the photo of the state machine from [Wikipedia](https://en.wikipedia.org/wiki/Transmission_Control_Protocol#/media/File:Tcp_state_diagram_fixed_new.svg) 
![img](/assets/images/tcp/tcp_state.png)

###### _By Scil100, CC BY-SA 3.0, <https://commons.wikimedia.org/w/index.php?curid=30810617>_ ######

This image from IBM makes it quite clear.

![img](/assets/images/tcp/tcp_state_1.png)

Note on terms:

-   **Active Open:** This is meant for the side in TCP that opens a connection to a server.
-   **Passive Open:** This is the server that is listening for incoming connection requests
-   **Active Close:** This is meant for the side that closes the connection first.
-   **Passive Close:** This is the side that passively closes the connection.

## TCP States ##

-   **LISTEN:** the TCP state where the end is listening for incoming connections requests, this is a passive open
-   **SYN_SENT:** waiting for a response from a remote tcp end after sending a new connection request
-   **SYN_RECEIVED:** this end has sent a SYN and an ACK in response to the incoming request and is waiting for an ACK from the other end
-   **ESTABLISHED:** The there way handshake is complete and communication can take place
-   **FIN_WAIT_1:** sender has sent a FIN and is waiting for and acknowledgement from the other side OR a simultaneous termination request from the other side
-   **FIN_WAIT_2:** side performing active close has received acknowledgement of FIN and is waiting to get a FIN back from the remote
-   **CLOSE_WAIT:** received close request from remote end and is waiting for a close from the application layer
-   **CLOSING:** the sender of termination request is waiting for an acknowledgement
-   **LAST_ACK:** waiting for ack of previously sent termination request
-   **TIME_WAIT:** waiting for enough time to pass to ensure that both sides has ack'ed the termination requests.
-   **CLOSED:** the TCP connection is closed


<a id="org9331cf6"></a>

## Tcp RST

A discussion on TCP is incomplete without talking about **RST**

RST is the TCP reset flag which is used to reset the TCP connection.

This is used when something that gone wrong and either end wants to
signal to reset the connection and start a new connection.


<a id="orgc33e07e"></a>

## TCP Flow Control (Window Size)

TCP implements flow control. TCP as a protocol is designed to be very
respectful of the transmission channel and the receiver. It cares if
the receiver is overwhelmed or not.

To enable flow control, every side involved in a TCP connection sends
a *window size* parameter in every TCP segment. This is used to signal
to the other side, the amount of receive buffer available.

Thus the receiver controls the rate according to the capabilities.

If for whatever reason, the receiver advertises a window size of 0,
then the sender stop transmission and starts a *persist* timer. Once
this timer runs out, it sends a small packet so that it can get an
updated window size on the acknowledgement from the receiver.


<a id="org449f10d"></a>

## TCP Congestion control

TCP uses acknowledgements and RTT information to guess the congestion
status of the network and control its rate.

Haven't studied this much. Will update this section when I do.


<a id="orge80387b"></a>

## TIME_WAIT Assassinations


<a id="org23b85fd"></a>

## Selective Acknowledgements (sack)
